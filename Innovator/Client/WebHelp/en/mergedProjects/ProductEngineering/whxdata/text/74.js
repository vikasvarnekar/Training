rh._.exports({"0":["Custom Effectivity String Notation Examples"],"1":["\n  ","\n  ","\n  ","The following examples show ways to customize the Effectivity String Notation.","\n  ","\n  ","The default Effectivity String Notations Converter uses a conjunction word for each logical operator:","\n  ","\n    ","AND ","for logical conjunction.","\n    ","OR ","for logical disjunction.","\n    ","NOT ","for logical complement.","\n  ","\n  ","For example:","\n  ","           ((Factory=Munich AND Production Date>= 01/01/2019) ","OR","\n                (Factory=Detroit AND Production Date >= 06/01/2019 ","AND","\n                       ","NOT ","(Body Type = Hatch back)","\n  ","The customized String Notation uses the following characters instead of the conjunction words:","\n  ","\n    ","&&"," for logical conjunction","\n    ","|| ","for logical disjunction","\n    ","!"," for logical complement","\n  ","\n  ","For example:","\n  ","         ((Factory=Munich ","&&"," Production Date >= 01/01/2019) ","||","\n          (Factory=Detroit ","&& ","Production Date >= 06/01/2019)) ","&&","\n                                "," !","(Body Type = HatchBack)","\n  ","\n  ","To achieve this customization goal, a new ","ExpressionToShortStringNotationConverter"," class is defined using the new Converter:","\n  ","internal class ExpressionToShortStringNotationConverter : Aras.Server.Core.Configurator.IStringNotationConverter","\n    {","\n        private readonly IEnumerable<Aras.Server.Core.Configurator.Variable> _variablesContainer;","\n  ","    private static readonly Dictionary<Type, Aras.Server.Core.Configurator.DataType> typeTranslator = new Dictionary<Type, Aras.Server.Core.Configurator.DataType>","\n        {","\n            { typeof(string), Aras.Server.Core.Configurator.DataType.String },","\n            { typeof(int), Aras.Server.Core.Configurator.DataType.Int },","\n            { typeof(DateTime), Aras.Server.Core.Configurator.DataType.DateTime }","\n        };","\n  ","    /// <summary>","\n        /// Initializes a new instance of the ExpressionToShortStringNotationConverter class with the defined variables container","\n        /// </summary>","\n        /// <param name=\"variablesContainer\">Represents a list of \"Aras.Server.Core.Configurator.Variable\" objects, which will be used to get human-readable identifiers of Variables and/or Named-constants</param>","\n        public CustomExpressionToStringNotationConverter(IEnumerable<Aras.Server.Core.Configurator.Variable> variablesContainer)","\n        {","\n            if (variablesContainer == null)","\n            {","\n                throw new ArgumentNullException(\"variablesContainer\");","\n            }","\n  ","        this._variablesContainer = variablesContainer;","\n        }","\n  ","    /// <summary>","\n        /// Converts an incoming \"Aras.Server.Core.Configurator.ExpressionBase\" Effectivity Expression object representation to a string notation and returns it.","\n        /// </summary>","\n        /// <param name=\"expression\">An Effectivity Expression object representation</param>","\n        /// <returns>A effectivity string notation value</returns>","\n        public string ConvertExpressionToStringNotation(Aras.Server.Core.Configurator.ExpressionBase expression)","\n        {","\n            if (expression == null)","\n            {","\n                throw new ArgumentNullException(\"expression\");","\n            }","\n  ","        return TranslateToStringNotationImplementation(expression, null);","\n        }","\n  ","    private string TranslateToStringNotationImplementation(Aras.Server.Core.Configurator.ExpressionBase expression, Aras.Server.Core.Configurator.ExpressionBase parentExpression)","\n        {","\n            if (expression.ExpressionType == Aras.Server.Core.Configurator.ExpressionType.Term)","\n            {","\n                Aras.Server.Core.Configurator.ExpressionTerm expressionTerm = expression as Aras.Server.Core.Configurator.ExpressionTerm;","\n  ","            string variableId = expressionTerm.OperandLeft.GetId();","\n                Aras.Server.Core.Configurator.Variable variable = _variablesContainer.FirstOrDefault(var => var.Id == variableId);","\n                string variableName = variable?.Name ?? variableId;","\n  ","            string assignedVariableValue;","\n                Aras.Server.Core.Configurator.ITermOperand expressionTermOperandRight = expressionTerm.OperandRight;","\n                if (expressionTermOperandRight.OperandType == Aras.Server.Core.Configurator.TermOperandType.NamedConstant)","\n                {","\n                    string namedConstantId = expressionTermOperandRight.GetId();","\n                    assignedVariableValue = variable?.Enum?.FindNamedConstantById(namedConstantId)?.Name ?? namedConstantId;","\n                }","\n                else if (expressionTermOperandRight.OperandType == Aras.Server.Core.Configurator.TermOperandType.Constant)","\n                {","\n                    object constantValue = expressionTermOperandRight.GetValue();","\n                    Type constantType = constantValue.GetType();","\n  ","                Aras.Server.Core.Configurator.DataType constantDataType;","\n                    if (!typeTranslator.TryGetValue(constantType, out constantDataType))","\n                    {","\n                        throw new NotSupportedException(FormattableString.Invariant($\"'{constantType.FullName}' constant data type is not supported as the right operand type for string notation conversion\"));","\n                    }","\n                    //'null' as the first parameter of the 'ToLocalString()' method call indicates the incoming DateTime object shouldn't be adjusted to any time zone, because it's assumed 'datetime' always is returned in neutral format with UTC time zone","\n                    assignedVariableValue = constantDataType != Aras.Server.Core.Configurator.DataType.DateTime ? Convert.ToString(constantValue, CultureInfo.InvariantCulture) : Aras.I18NUtils.DateTimeConverter.ToLocalString(null, (DateTime)constantValue);","\n                }","\n                else","\n                {","\n                    throw new NotSupportedException(FormattableString.Invariant($\"{expressionTerm.OperandRight.OperandType} is not supported as the right operand type for string notation conversion\"));","\n                }","\n  ","            return string.Format(CultureInfo.InvariantCulture, \"{0} {1} {2}\", AddSquareBracketsIfNeed(variableName), GetAlgebraicTermOperatorNotation(expressionTerm.Operator), AddSquareBracketsIfNeed(assignedVariableValue));","\n            }","\n  ","        string expressionStringNotation = string.Empty;","\n            string expressionOperatorStrNotation = GetAlgebraicNotationByOperator(expression.ExpressionType);","\n            //we assume at-least-one, at-most-one, exactly-one expressions consists of terms(<EQ><variable id=\"\" /><named-constant id=\"\" /></EQ>) only here","\n            if (expression.ExpressionType == Aras.Server.Core.Configurator.ExpressionType.AtLeastOne ||","\n                expression.ExpressionType == Aras.Server.Core.Configurator.ExpressionType.AtMostOne ||","\n                expression.ExpressionType == Aras.Server.Core.Configurator.ExpressionType.ExactlyOne)","\n            {","\n                IEnumerable<string> innerTermsStringNotation = expression.InnerExpressions.Select(expr => TranslateToStringNotationImplementation(expr, expression));","\n                return string.Format(CultureInfo.InvariantCulture, expressionOperatorStrNotation, string.Join(\" | \", innerTermsStringNotation));","\n            }","\n  ","        foreach (Aras.Server.Core.Configurator.ExpressionBase innerExpression in expression.InnerExpressions)","\n            {","\n                string innerExpressionStrNotation = TranslateToStringNotationImplementation(innerExpression, expression);","\n                if (!string.IsNullOrEmpty(innerExpressionStrNotation))","\n                {","\n                    if (expression.ExpressionType == Aras.Server.Core.Configurator.ExpressionType.NOT)","\n                    {","\n                        expressionStringNotation += string.Format(CultureInfo.InvariantCulture, expressionOperatorStrNotation, innerExpressionStrNotation);","\n                    }","\n                    else if (expression.ExpressionType == Aras.Server.Core.Configurator.ExpressionType.IMPLICATION)","\n                    {","\n                        string[] ifThen = expressionOperatorStrNotation.Split(' ');","\n                        bool isStringNotationEmpty = string.IsNullOrEmpty(expressionStringNotation);","\n  ","                    // implicationTemplate describes \"IF {expr}\" or \"THEN {expr}\". In case \"IF\", whitespace after \"{expr}\" is required -\"IF {expr} \"","\n                        string implicationTemplate = isStringNotationEmpty ? \"{0} {1} \" : \"{0} {1}\";","\n                        expressionStringNotation += string.Format(CultureInfo.InvariantCulture, implicationTemplate, ifThen[isStringNotationEmpty ? 0 : 1], innerExpressionStrNotation);","\n                    }","\n                    else","\n                    {","\n                        expressionStringNotation += !string.IsNullOrEmpty(expressionStringNotation) ? expressionOperatorStrNotation + innerExpressionStrNotation : innerExpressionStrNotation;","\n                    }","\n                }","\n            }","\n  ","        return parentExpression != null && parentExpression.InnerExpressions.Count > 1 &&","\n                parentExpression.ExpressionType != Aras.Server.Core.Configurator.ExpressionType.IMPLICATION && expression.ExpressionType != Aras.Server.Core.Configurator.ExpressionType.NOT ?","\n                \"(\" + expressionStringNotation + \")\" : expressionStringNotation;","\n        }","\n  ","    private static string AddSquareBracketsIfNeed(string name)","\n        {","\n            return !string.IsNullOrEmpty(name) && !System.Text.RegularExpressions.Regex.IsMatch(name, @\"^[a-zA-Z0-9]+$\") ?","\n                    string.Format(CultureInfo.InvariantCulture, \"[{0}]\", name) : name;","\n        }","\n  ","    private static string GetAlgebraicNotationByOperator(Aras.Server.Core.Configurator.ExpressionType boolOperator)","\n        {","\n            string notation = string.Empty;","\n            switch (boolOperator)","\n            {","\n                case Aras.Server.Core.Configurator.ExpressionType.AND:","\n                    notation = \" && \";","\n                    break;","\n                case Aras.Server.Core.Configurator.ExpressionType.OR:","\n                    notation = \" || \";","\n                    break;","\n                case Aras.Server.Core.Configurator.ExpressionType.NOT:","\n                    notation = \"!({0})\";","\n                    break;","\n                case Aras.Server.Core.Configurator.ExpressionType.IMPLICATION:","\n                    notation = \"IF THEN\";","\n                    break;","\n                case Aras.Server.Core.Configurator.ExpressionType.AtLeastOne:","\n                    notation = \"AT-LEAST-ONE({0})\";","\n                    break;","\n                case Aras.Server.Core.Configurator.ExpressionType.AtMostOne:","\n                    notation = \"AT-MOST-ONE({0})\";","\n                    break;","\n                case Aras.Server.Core.Configurator.ExpressionType.ExactlyOne:","\n                    notation = \"EXACTLY-ONE({0})\";","\n                    break;","\n                default:","\n                    throw new NotSupportedException(boolOperator + \" type is not supported for string notation conversion\");","\n            }","\n  ","        return notation;","\n        }","\n  ","    private static string GetAlgebraicTermOperatorNotation(Aras.Server.Core.Configurator.TermOperator termOperator)","\n        {","\n            string algebraicTermOperatorNotation;","\n            switch (termOperator)","\n            {","\n                case Aras.Server.Core.Configurator.TermOperator.Equal:","\n                    algebraicTermOperatorNotation = \"=\";","\n                    break;","\n                case Aras.Server.Core.Configurator.TermOperator.GreaterThanOrEqual:","\n                    algebraicTermOperatorNotation = \">=\";","\n                    break;","\n                case Aras.Server.Core.Configurator.TermOperator.LessThanOrEqual:","\n                    algebraicTermOperatorNotation = \"<=\";","\n                    break;","\n                default:","\n                    throw new NotSupportedException(FormattableString.Invariant($\"'{termOperator}' term operator is not supported for string notation conversion\"));","\n            }","\n  ","        return algebraicTermOperatorNotation;","\n        }","\n    }","\n     ","\n  ","\n  ","By default, a comma (,) is used to combine multiple Effectivities on a single Relationship. A customized String Notation uses the OR conjunction word instead of the comma.","\n  ","         ","\n  ","\n    ","\n      ","\n      ","\n      ","\n      ","\n    ","\n    ","\n      ","\n        ","\n          ","Effective Item","\n        ","\n        ","\n          ","Single Effectivity String Notations","\n        ","\n        ","\n          ","Unified Effectivity String Notation","\n        ","\n      ","\n      ","\n        ","Default","\n        ","Customized","\n      ","\n      ","\n        ","Engine","\n        ","Factory = Detroit","\n        ","(Factory = Detroit), (Factory = Munich)","\n        ","(Factory = Detroit) OR (Factory = Munich)","\n      ","\n      ","\n        ","Factory = Munich","\n      ","\n    ","\n  ","\n  ","\n  ","To achieve this customization goal, change the definition of the JoinExpressionStringNotation internal method of the effs_getExpressionStringNotation method as follows:","\n  ","internal virtual string JoinExpressionStringNotation(IEnumerable<string> expressionStringNotations)","\n    {","\n        if (!string.IsNullOrEmpty(expressionStringNotations.ElementAtOrDefault(1)))","\n        {","\n            expressionStringNotations = expressionStringNotations.Select(","\n            expressionStringNotation => \"(\" + expressionStringNotation + \")\");","\n        }","\n        return string.Join(\" OR \", expressionStringNotations);","\n    }","\n  ","\n\n","\n  ","\n    "," ","\n    ","©2020 Aras Corporation - All Rights Reserved","\n  ","\n\n"],"2":["Custom Effectivity String Notation Examples"],"3":["Custom Effectivity String Notation on an Effectivity Expression","ExpressionToShortStringNotationConverter Class Definition","Custom Unified Effectivity String Notation"," "],"4":["JoinExpressionStringNotation Method Definition"],"id":"74"})